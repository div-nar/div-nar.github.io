<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>div | escape v.</title>
    <meta name="description" content="developer, builder, creator.">
    <link rel="stylesheet" href="style.css">
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

<!-- ══════════════════════════════════════════
     HEADER
══════════════════════════════════════════ -->
<header class="site-header">
    <div>
        <h1>DIVITH NARENDRA</h1>
        <div class="header-subhead dim">Saturn V personifies ambition to me. My site aims to highlight what we've forgotten the Saturn V stands for: ambition.</div>
        <div class="dim">PRODUCT // BUILDER // FOUNDER'S GUY // <a href="writing.html">WRITING</a> // <a href="https://drive.google.com/file/d/1ryd-BLh5Y7xK2psEldVXcmuJJ6fnUdoq/view?usp=sharing" target="_blank">RESUME</a></div>
    </div>
    <div class="header-right dim">
        <div>CURRENT_LOC: BANGALORE</div>
        <div>STATUS: <span class="typing-cursor">ORBITAL</span></div>
    </div>
</header>

<!-- ══════════════════════════════════════════
     SCROLL WRAPPER: full-height sticky rocket
     + content panels alongside
══════════════════════════════════════════ -->
<div class="scroll-wrapper" id="scroll-wrapper">

    <!-- Fixed rocket (centred) -->
    <div class="rocket-sticky" id="rocket-sticky">
        <canvas id="rocket-canvas"></canvas>

        <!-- Stage labels — sit left/right of rocket, revealed per group -->
        <div class="stage-labels" id="stage-labels">
            <div class="stage-label-item" id="lbl-csm" data-side="right">
                <div class="lbl-badge">CSM</div>
                <div class="lbl-sub dim">COMMAND + SERVICE MODULE</div>
                <div class="lbl-desc dim">The crew's capsule. Housed three astronauts for the entire mission — from launch to splashdown — and the only part that came back.</div>
            </div>
            <div class="stage-label-item" id="lbl-sivb" data-side="right">
                <div class="lbl-badge">S-IVB</div>
                <div class="lbl-sub dim">THIRD STAGE + LEM</div>
                <div class="lbl-desc dim">Single J-2 engine. Burned once to reach orbit, then again for trans-lunar injection — the push that sent the crew toward the Moon.</div>
            </div>
            <div class="stage-label-item" id="lbl-sii" data-side="right">
                <div class="lbl-badge">S-II</div>
                <div class="lbl-sub dim">SECOND STAGE</div>
                <div class="lbl-desc dim">Five J-2 engines burning liquid hydrogen. Carried the stack through the upper atmosphere to 115 miles altitude at 15,000 mph.</div>
            </div>
            <div class="stage-label-item" id="lbl-coupler" data-side="right">
                <div class="lbl-badge">INTERSTAGE</div>
                <div class="lbl-sub dim">S-II / S-IC COUPLER</div>
                <div class="lbl-desc dim">Structural ring connecting the first and second stages. Jettisoned seconds after S-IC separation at roughly 38 miles altitude.</div>
            </div>
            <div class="stage-label-item" id="lbl-sic" data-side="right">
                <div class="lbl-badge">S-IC</div>
                <div class="lbl-sub dim">FIRST STAGE</div>
                <div class="lbl-desc dim">Five F-1 engines producing 7.5 million pounds of thrust. Burned 20 tons of fuel per second for 150 seconds to clear the atmosphere.</div>
            </div>
        </div>
    </div>

    <!-- Content panels stacked vertically, overlaid on the sticky rocket -->
    <div class="content-col" id="content-col">

        <!-- ── PANEL 0: Intro (triggers payload separation) ── -->
        <div class="content-panel" id="panel-intro" data-stage="csm">
            <div class="panel-card card-left">
                <div class="section-label dim">MISSION PROFILE</div>
                <p class="mission-text">
                    Part-time writer, full-time product.<br><br>
                    The Saturn V remains the most powerful machine ever built by human hands.
                    It did not compromise. It burned 20 tons of fuel per second to escape gravity.<br><br>
                    This is the operating protocol for my work:<br>
                    <strong>Escape velocity or nothing.</strong>
                </p>
                <nav class="contact-nav">
                    <a href="mailto:divithnarendra@gmail.com">[ EMAIL ]</a>
                    <a href="https://www.linkedin.com/in/divith-narendra/" target="_blank">[ LINKEDIN ]</a>
                    <a href="https://x.com/div_narendra" target="_blank">[ TWITTER ]</a>
                    <a href="https://kwerky.substack.com/" target="_blank">[ SUBSTACK ]</a>
                </nav>
            </div>
        </div>

        <!-- ── PANEL 1: S-IVB — Experience (Dognosis + Lossfunk) ── -->
        <div class="content-panel" id="panel-sivb" data-stage="sivb">
            <div class="panel-card card-left">
                <div class="card-sublabel">EXPERIENCE</div>
                <a href="https://www.dognosis.tech" class="stage-entry" target="_blank">
                    <div class="entry-row">
                        <div>
                            <div class="entry-title">DOGNOSIS</div>
                            <div class="entry-role">FOUNDER'S OFFICE</div>
                            <div class="entry-desc">Helping run a company proving that dogs + machine learning outperform half your favorite diagnostic tools.</div>
                        </div>
                        <div class="entry-date">OCT 2025 –<br>PRESENT</div>
                    </div>
                </a>
                <a href="https://x.com/paraschopra/status/2011702947848032656" class="stage-entry" target="_blank">
                    <div class="entry-row">
                        <div>
                            <div class="entry-title">LOSSFUNK</div>
                            <div class="entry-role">AI RESIDENT</div>
                            <div class="entry-desc">Teaching LLMs to play Age of Empires and real-time strategy games. Because if AI can manage an economy, defend a base, and execute a 200 IQ rush — maybe it deserves the job.</div>
                        </div>
                        <div class="entry-date">JAN –<br>MAR 2026</div>
                    </div>
                </a>
            </div>
        </div>

        <!-- ── PANEL 2: S-II — Experience (ISB + August AI) ── -->
        <div class="content-panel" id="panel-sii" data-stage="sii">
            <div class="panel-card card-left">
                <div class="card-sublabel">EXPERIENCE</div>
                <a href="https://www.meetaugust.ai/" class="stage-entry" target="_blank">
                    <div class="entry-row">
                        <div>
                            <div class="entry-title">AUGUST AI</div>
                            <div class="entry-role">FOUNDER'S OFFICE</div>
                            <div class="entry-desc">Shipped fast, broke nothing, and somehow convinced 80k people to show up in a week.</div>
                        </div>
                        <div class="entry-date">NOV 2024 –<br>MAY 2025</div>
                    </div>
                </a>
                <a href="https://www.canva.com/design/DAF_jT1HcDk/I7hYO04TESmufHTBj6MczQ/edit" class="stage-entry" target="_blank">
                    <div class="entry-row">
                        <div>
                            <div class="entry-title">INDIAN SCHOOL OF BUSINESS</div>
                            <div class="entry-role">ANALYST</div>
                            <div class="entry-desc">Explained to markets why weather exists and why it keeps ruining everyone's predictions.</div>
                        </div>
                        <div class="entry-date">MAY –<br>AUG 2024</div>
                    </div>
                </a>
            </div>
        </div>

        <!-- ── PANEL 3: S-IC — Projects & Research ── -->
        <div class="content-panel" id="panel-sic" data-stage="sic">
            <div class="panel-card card-left">
                <div class="card-sublabel">PROJECTS</div>
                <a href="https://drive.google.com/file/d/17QzwbwJoRpvBeVEyxWDCIcEAQmTamIGA/view?usp=sharing" class="stage-entry" target="_blank">
                    <div class="entry-row">
                        <div>
                            <div class="entry-title">CLIMATE-ADJUSTED PORTFOLIO</div>
                            <div class="entry-role">RESEARCH PROJECT</div>
                            <div class="entry-desc">Modified CAPM to treat carbon emissions like bad debt — saving the planet also beats the market.</div>
                        </div>
                        <div class="entry-date">OCT –<br>DEC 2024</div>
                    </div>
                </a>
                <a href="empathetic-machines.pdf" class="stage-entry" target="_blank">
                    <div class="entry-row">
                        <div>
                            <div class="entry-title">EMPATHETIC MACHINES</div>
                            <div class="entry-role">RESEARCH PAPER</div>
                            <div class="entry-desc">Wrote a research paper in 7 days exploring if machines can feel. Spoiler: they can't, but they're getting better at pretending.</div>
                        </div>
                        <div class="entry-date">MAY 2024</div>
                    </div>
                </a>
                <a href="https://github.com/anshulranaa/AT-GCN" class="stage-entry" target="_blank">
                    <div class="entry-row">
                        <div>
                            <div class="entry-title">FORECASTING FATALITIES</div>
                            <div class="entry-role">ML RESEARCH</div>
                            <div class="entry-desc">Trained a model to predict conflict fatalities without starting any new ones.</div>
                        </div>
                        <div class="entry-date">JAN –<br>MAY 2024</div>
                    </div>
                </a>
            </div>
        </div>

        <!-- ── PANEL 4: Transmission Logs (replaces career chart) ── -->
        <div class="content-panel content-panel--fullwidth" id="panel-transmissions" data-stage="liftoff">
            <div class="transmissions-section">
                <div class="transmissions-header">
                    <h2 class="typing-cursor">TRANSMISSION LOGS</h2>
                    <div class="dim" style="font-size:11px;margin-top:8px">MY WRITING ON TECH, STARTUPS AND THE BROADER CULTUROSPHERE</div>
                </div>
                <div class="transmissions-grid" id="transmissions-container">
                    <div class="transmission-item">
                        <div class="entry-title dim">LOADING_TRANSMISSIONS...</div>
                    </div>
                </div>
                <div class="transmissions-footer">
                    <a href="writing.html">[ VIEW ALL TRANSMISSIONS ]</a>
                    <a href="https://kwerky.substack.com/" target="_blank">[ SUBSTACK_FEED ]</a>
                </div>
            </div>
        </div>

        <footer class="site-footer">
            <p>// DIVITH NARENDRA // SYSTEM STATUS: ONLINE // 2025 //</p>
        </footer>

    </div><!-- /content-col -->
</div><!-- /scroll-wrapper -->


<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ── Component groups (4 layers) ───────────────────────────────
// Node names in GLB: tower, cmd, svc, lem, sivb, sii, cpv2, sic_top, sic_bot, fin_0-3
const MESH_TO_GROUP = {
    'tower':   'csm',
    'cmd':     'csm',
    'svc':     'csm',
    'lem':     'sivb',
    'sivb':    'sivb',
    'sii':     'sii',
    'cpv2':    'coupler',
    'sic_top': 'sic',
    'sic_bot': 'sic',
    'fin':     'sic',
};
const ALL_GROUPS = ['csm', 'sivb', 'sii', 'coupler', 'sic'];

// Each group's geometric midpoint Y (rest position in model space)
const GROUP_MID_Y = {
    csm:     3.994,
    sivb:    2.019,
    sii:     -0.11,
    coupler: -1.042,
    sic:     -3.021,
};

// Camera zoom per stage (closer for smaller groups)
const CAM_Z = {
    none:          28,
    csm:           7,
    sivb:          9,
    sii:           10,
    coupler:       10,
    sic:           12,
    'pre-liftoff': 28,
    liftoff:       28,
};

// ── Mobile detection ─────────────────────────────────────────
const isMobile = window.matchMedia('(max-width: 768px)').matches;

// ── Renderer setup ───────────────────────────────────────────
const canvas  = document.getElementById('rocket-canvas');
const sticky  = document.getElementById('rocket-sticky');

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
renderer.setClearColor(0x000000, 1);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.1 : 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.06;
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(isMobile ? 26 : 28, 1, 0.01, 200);
camera.position.set(0, 0, 28);

// ── Lighting for full shaded rocket rendering ────────────────
const hemiLight = new THREE.HemisphereLight(0xf4f7ff, 0x050505, 0.58);
scene.add(hemiLight);
const keyLight = new THREE.DirectionalLight(0xffffff, 1.55);
keyLight.position.set(8, 5, 9);
scene.add(keyLight);
const rimLight = new THREE.DirectionalLight(0xd5def0, 0.72);
rimLight.position.set(-9, 2.5, -7);
scene.add(rimLight);
const topFill = new THREE.DirectionalLight(0xffffff, 0.34);
topFill.position.set(0, 12, 1);
scene.add(topFill);
const engineGlow = new THREE.PointLight(0xaec0df, 0.2, 45, 2);
engineGlow.position.set(0, -6.5, 0);
scene.add(engineGlow);

// ── Post-processing (desktop only) ───────────────────────────
const usePostFX = !isMobile;
let composer = null;
if (usePostFX) {
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.2, // strength — restrained
        0.7, // radius
        0.74 // threshold
    );
    composer.addPass(bloomPass);
}

function resize() {
    const w = sticky.clientWidth;
    const h = sticky.clientHeight;
    renderer.setSize(w, h);
    if (composer) composer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
}
resize();
window.addEventListener('resize', resize);

// ── Per-group shaded materials ───────────────────────────────
const stageMats = {};
const stageGroups = {};
for (const k of ALL_GROUPS) {
    stageMats[k]    = [];
    stageGroups[k]  = new THREE.Group();
}
const rocketRoot = new THREE.Group();
for (const g of Object.values(stageGroups)) rocketRoot.add(g);
scene.add(rocketRoot);
rocketRoot.rotation.x = 0.10; // slight forward tilt

// ── Classify mesh by node name → group ───────────────────────
function nameToGroup(meshName) {
    const lower = meshName.toLowerCase();
    for (const [key, group] of Object.entries(MESH_TO_GROUP)) {
        if (lower.includes(key)) return group;
    }
    return 'sic';
}

const STAGE_PALETTE = {
    csm: { color: 0xd2d5da, metalness: 0.03, roughness: 0.84, emissive: 0x07080a },
    sivb: { color: 0xf2f2f0, metalness: 0.0, roughness: 0.9, emissive: 0x07080a },
    sii: { color: 0xf2f2f0, metalness: 0.0, roughness: 0.9, emissive: 0x07080a },
    coupler: { color: 0xf2f2f0, metalness: 0.0, roughness: 0.92, emissive: 0x050608 },
    sic: { color: 0xf2f2f0, metalness: 0.0, roughness: 0.9, emissive: 0x050608 },
};

function applyStagePaint(material, stageKey, meshName, yMin, yMax) {
    const STAGE_INDEX = { csm: 0, sivb: 1, sii: 2, coupler: 3, sic: 4 };
    const isCommand = Number(meshName.toLowerCase().includes('cmd'));
    const isTower = Number(meshName.toLowerCase().includes('tower'));

    material.onBeforeCompile = (shader) => {
        shader.uniforms.uStageIndex = { value: STAGE_INDEX[stageKey] ?? 4 };
        shader.uniforms.uIsCommand = { value: isCommand };
        shader.uniforms.uIsTower = { value: isTower };
        shader.uniforms.uYMin = { value: yMin };
        shader.uniforms.uYMax = { value: yMax };

        shader.vertexShader = shader.vertexShader
            .replace(
                '#include <common>',
                `#include <common>
                varying vec3 vLocalPos;`
            )
            .replace(
                '#include <begin_vertex>',
                `#include <begin_vertex>
                vLocalPos = position;`
            );

        shader.fragmentShader = shader.fragmentShader
            .replace(
                '#include <common>',
                `#include <common>
                varying vec3 vLocalPos;
                uniform float uStageIndex;
                uniform float uIsCommand;
                uniform float uIsTower;
                uniform float uYMin;
                uniform float uYMax;

                vec3 paintForStage(float yNorm, float ang01, float stageIndex, float isCmd, float isTwr) {
                    vec3 saturnWhite = vec3(0.949, 0.949, 0.941); // #F2F2F0
                    vec3 saturnBlack = vec3(0.067, 0.067, 0.067); // #111111
                    vec3 alu = vec3(0.824, 0.835, 0.855);
                    vec3 heatShield = vec3(0.30, 0.22, 0.16);
                    vec3 outColor = saturnWhite;

                    if (stageIndex < 0.5) {
                        outColor = alu;
                        if (isCmd > 0.5 && yNorm < 0.18) outColor = heatShield;
                        if (isTwr > 0.5) {
                            outColor = saturnWhite;
                            float towerMark = step(0.86, fract(ang01 * 8.0));
                            if (towerMark > 0.5 && yNorm > 0.15 && yNorm < 0.88) outColor = saturnBlack;
                        }
                    } else if (stageIndex < 1.5) {
                        outColor = saturnWhite;
                        if (yNorm < 0.08) outColor = saturnBlack;   // optional lower thin band
                        if (yNorm > 0.92) outColor = saturnBlack;   // instrument unit ring
                        if (yNorm > 0.08 && yNorm < 0.092) outColor = saturnBlack; // crisp lower stage seam
                    } else if (stageIndex < 2.5) {
                        outColor = saturnWhite;
                        if (yNorm < 0.34) {
                            float s = fract(ang01 * 6.0);
                            if (abs(s - 0.5) < 0.30) outColor = saturnBlack;
                        }
                        if (yNorm > 0.34 && yNorm < 0.353) outColor = saturnBlack; // S-II pattern boundary seam
                    } else if (stageIndex < 3.5) {
                        outColor = saturnWhite;
                        float c = ang01;
                        float blk = 0.0;
                        if ((c > 0.02 && c < 0.10) || (c > 0.15 && c < 0.24) || (c > 0.31 && c < 0.43)
                            || (c > 0.49 && c < 0.58) || (c > 0.67 && c < 0.76) || (c > 0.84 && c < 0.94)) {
                            blk = 1.0;
                        }
                        if (blk > 0.5) outColor = saturnBlack;
                    } else {
                        outColor = saturnWhite;
                        if (yNorm < 0.30) {
                            float s = fract(ang01 * 5.0);
                            float width = mix(0.84, 0.96, clamp(yNorm / 0.30, 0.0, 1.0));
                            if (abs(s - 0.5) < width * 0.5) outColor = saturnBlack;
                        }
                        if (yNorm > 0.47 && yNorm < 0.53) outColor = saturnBlack;
                        if (yNorm > 0.30 && yNorm < 0.312) outColor = saturnBlack; // S-IC lower panel boundary seam
                    }
                    return outColor;
                }`
            )
            .replace(
                '#include <color_fragment>',
                `#include <color_fragment>
                float yNorm = clamp((vLocalPos.y - uYMin) / max(0.0001, (uYMax - uYMin)), 0.0, 1.0);
                float theta = atan(vLocalPos.z, vLocalPos.x);
                float ang01 = fract((theta + 3.14159265359) / 6.28318530718);
                vec3 paint = paintForStage(yNorm, ang01, uStageIndex, uIsCommand, uIsTower);
                diffuseColor.rgb = paint;`
            );
    };
    material.customProgramCacheKey = () => `saturn-paint-${stageKey}-${isCommand}-${isTower}-${yMin.toFixed(4)}-${yMax.toFixed(4)}`;
    material.needsUpdate = true;
}

function makeStageMaterial(srcMat, stageKey, meshName, yMin, yMax) {
    const palette = STAGE_PALETTE[stageKey] || STAGE_PALETTE.sic;
    const m = srcMat ? srcMat.clone() : new THREE.MeshStandardMaterial({
        color: palette.color,
        metalness: palette.metalness,
        roughness: palette.roughness,
    });
    if ('map' in m) m.map = null;
    if ('color' in m) m.color.set(palette.color);
    if ('metalness' in m) m.metalness = palette.metalness;
    if ('roughness' in m) m.roughness = palette.roughness;
    if ('emissive' in m) m.emissive.set(palette.emissive);
    if ('emissiveIntensity' in m) m.emissiveIntensity = 0.06;
    m.transparent = true;
    m.opacity = 0.35;
    applyStagePaint(m, stageKey, meshName, yMin, yMax);
    return m;
}

// ── Build shaded meshes from GLB ─────────────────────────────
function buildFromGLTF(gltfScene) {
    gltfScene.traverse(child => {
        if (!child.isMesh) return;
        const key = nameToGroup(child.name);
        child.geometry.computeBoundingBox();
        const box = child.geometry.boundingBox;
        const yMin = box ? box.min.y : -0.5;
        const yMax = box ? box.max.y : 0.5;

        const mat = Array.isArray(child.material)
            ? child.material.map(m => makeStageMaterial(m, key, child.name, yMin, yMax))
            : makeStageMaterial(child.material, key, child.name, yMin, yMax);

        if (Array.isArray(mat)) stageMats[key].push(...mat);
        else stageMats[key].push(mat);

        const mesh = new THREE.Mesh(child.geometry, mat);
        mesh.position.copy(child.position);
        mesh.quaternion.copy(child.quaternion);
        mesh.scale.copy(child.scale);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        stageGroups[key].add(mesh);
    });
}

const loader = new GLTFLoader();
loader.load('rocket-full.glb', gltf => {
    buildFromGLTF(gltf.scene);
}, undefined, err => console.error(err));

// ── Scroll / stage state ─────────────────────────────────────
let activeStage = 'none';

// Opacity: target and smoothed current
const opacityTarget  = {};
const opacityCurrent = {};
for (const k of ALL_GROUPS) { opacityTarget[k] = 0.35; opacityCurrent[k] = 0.35; }

// Vertical separation: Y-offset targets and smoothed current
const SEP_GAP = isMobile ? 1.35 : 3.0; // gap between separated groups
const sepTarget  = {};
const sepCurrent = {};
for (const k of ALL_GROUPS) { sepTarget[k] = 0; sepCurrent[k] = 0; }

// Camera: stage-specific framing and angle
const CAM_POSE = {
    none: { x: 0.0, y: 0.0, z: 28.0, lookY: 0.0, rotY: 0.0 },
    csm: { x: 1.9, y: 0.45, z: 7.0, lookY: 0.2, rotY: -0.2 },
    sivb: { x: -1.4, y: 0.15, z: 9.0, lookY: 0.1, rotY: 0.28 },
    sii: { x: 1.6, y: -0.1, z: 10.0, lookY: -0.1, rotY: -0.32 },
    coupler: { x: -1.2, y: 0.0, z: 10.0, lookY: -0.05, rotY: 0.18 },
    sic: { x: 2.1, y: -0.4, z: 12.0, lookY: -0.45, rotY: -0.38 },
    'pre-liftoff': { x: 0.0, y: 0.2, z: 28.0, lookY: 0.0, rotY: 0.0 },
    liftoff: { x: 0.0, y: 0.3, z: 28.0, lookY: 0.0, rotY: 0.0 },
};

let camXTarget = 0, camYTarget = 0, camZTarget = 28, camLookYTarget = 0;
let camXCurrent = 0, camYCurrent = 0, camZCurrent = 28, camLookYCurrent = 0;
let stageRotYTarget = 0, stageRotYCurrent = 0;

// Liftoff state
let liftoffActive = false;
let liftoffYTarget = 0, liftoffYCurrent = 0;

// Panel → group mapping
const panels = ['panel-intro', 'panel-sivb', 'panel-sii', 'panel-sic', 'panel-transmissions'];
const panelStage = {
    'panel-intro': 'csm',
    'panel-sivb':  'sivb',
    'panel-sii':   'sii',
    'panel-sic':   'sic',
    'panel-transmissions': 'pre-liftoff',
};

// Group ordering for separation math (top → bottom)
const GROUP_ORDER = ['csm', 'sivb', 'sii', 'coupler', 'sic'];

let preLiftoffTimer = null;

function setActiveStage(newStage) {
    // Cancel pre-liftoff timer if scrolling away from transmissions
    if (newStage !== 'pre-liftoff' && newStage !== 'liftoff') {
        if (preLiftoffTimer) { clearTimeout(preLiftoffTimer); preLiftoffTimer = null; }
    }

    if (newStage === activeStage) return;
    activeStage = newStage;

    // ── Pre-liftoff: show assembled S-IC briefly, then fire liftoff ──
    if (newStage === 'pre-liftoff') {
        liftoffActive = false;
        // Reassemble rocket (all groups return to rest), zoom out
        for (const k of ALL_GROUPS) { opacityTarget[k] = 0.35; sepTarget[k] = 0; }
        const prePose = CAM_POSE['pre-liftoff'];
        camXTarget = prePose.x;
        camYTarget = prePose.y;
        camZTarget = prePose.z;
        camLookYTarget = prePose.lookY;
        stageRotYTarget = prePose.rotY;

        preLiftoffTimer = setTimeout(() => {
            liftoffActive = true;
            // activeStage stays 'pre-liftoff' — liftoffActive drives the rise
        }, 1500);

        // Hide all stage labels
        document.getElementById('stage-labels').style.display = 'none';
        for (const k of ALL_GROUPS) {
            const el = document.getElementById('lbl-' + k);
            if (el) el.classList.remove('active');
        }
        return;
    }

    liftoffActive = (newStage === 'liftoff');

    // Show/hide stage labels container
    const stageLabelsEl = document.getElementById('stage-labels');
    if (newStage === 'none' || newStage === 'liftoff') {
        stageLabelsEl.style.display = 'none';
    } else {
        stageLabelsEl.style.display = '';
    }

    // Opacity targets
    for (const k of ALL_GROUPS) {
        if (newStage === 'none' || newStage === 'liftoff') {
            opacityTarget[k] = 0.35;
        } else if (k === 'coupler') {
            // Hide coupler whenever showing decomposed stage views
            opacityTarget[k] = 0.0;
        } else {
            opacityTarget[k] = (k === newStage) ? 0.9 : 0.1;
        }
    }

    // Separation strategy:
    // - Translate active group so its midpoint lands at y=0 (camera centre)
    // - Push inactive groups further away with SEP_GAP spacing
    if (newStage === 'none' || newStage === 'liftoff') {
        for (const k of ALL_GROUPS) sepTarget[k] = 0;
    } else {
        const activeMidY = GROUP_MID_Y[newStage];
        const activeIdx = GROUP_ORDER.indexOf(newStage);
        for (let i = 0; i < GROUP_ORDER.length; i++) {
            const k = GROUP_ORDER[i];
            let offset = -activeMidY;
            if (i !== activeIdx) {
                const dir = i < activeIdx ? 1 : -1;
                const dist = Math.abs(i - activeIdx);
                offset += dir * SEP_GAP * dist;
            }
            sepTarget[k] = offset;
        }
    }

    // Camera pose target
    const pose = CAM_POSE[newStage] || CAM_POSE.none;
    camXTarget = pose.x;
    camYTarget = pose.y;
    camZTarget = pose.z;
    camLookYTarget = pose.lookY;
    stageRotYTarget = pose.rotY;

    // Stage label UI — ensure exactly one active label at a time
    for (const k of ALL_GROUPS) {
        const el = document.getElementById('lbl-' + k);
        if (el) el.classList.remove('active');
    }
    const activeLabel = document.getElementById('lbl-' + newStage);
    if (activeLabel) activeLabel.classList.add('active');
}

function updateStageFromScroll() {
    const vh = window.innerHeight;

    // Find panel whose centre is closest to viewport centre
    let bestPanel = null, bestDist = Infinity;
    for (const id of panels) {
        const el = document.getElementById(id);
        if (!el) continue;
        const r = el.getBoundingClientRect();
        const mid = r.top + r.height / 2;
        const dist = Math.abs(mid - vh / 2);
        if (dist < bestDist) { bestDist = dist; bestPanel = id; }
    }

    const threshold = vh;
    let resolvedPanel = (bestPanel && bestDist < threshold) ? bestPanel : null;

    // Mobile hysteresis: prevent stage flapping around panel boundaries
    if (isMobile && activeStage !== 'none' && resolvedPanel) {
        const stageToPanel = {
            csm: 'panel-intro',
            sivb: 'panel-sivb',
            sii: 'panel-sii',
            sic: 'panel-sic',
            'pre-liftoff': 'panel-transmissions',
        };
        const currentPanel = stageToPanel[activeStage];
        if (currentPanel && currentPanel !== resolvedPanel) {
            const currentEl = document.getElementById(currentPanel);
            if (currentEl) {
                const cr = currentEl.getBoundingClientRect();
                const currentDist = Math.abs((cr.top + cr.height / 2) - vh / 2);
                const SWITCH_MARGIN = 110;
                if (bestDist + SWITCH_MARGIN >= currentDist) {
                    resolvedPanel = currentPanel;
                }
            }
        }
    }

    const newStage = resolvedPanel ? panelStage[resolvedPanel] : 'none';

    setActiveStage(newStage);
}

let scrollTicking = false;
function onScroll() {
    if (scrollTicking) return;
    scrollTicking = true;
    requestAnimationFrame(() => {
        scrollTicking = false;
        updateStageFromScroll();
    });
}

window.addEventListener('scroll', onScroll, { passive: true });
window.addEventListener('resize', onScroll, { passive: true });
updateStageFromScroll();

// ── Mouse X rotation influence ───────────────────────────────
let mouseX = 0, targetRotY = 0, currentRotY = 0;
if (!isMobile) {
    window.addEventListener('mousemove', e => {
        mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
        // ±0.4 rad influence from mouse
        targetRotY = mouseX * 0.4;
    });
}

// ── LOX drip particle system (S-IC only) ─────────────────────
const LOX_COUNT = isMobile ? 40 : 200;
const LOX_FALL_DIST = 1.2;
const LOX_COLOR = new THREE.Color(0xeeeeff);
const LOX_CFG = { y: -5.0, r: 0.45 };

const loxPositions  = new Float32Array(LOX_COUNT * 3);
const loxOpacities  = new Float32Array(LOX_COUNT);
const loxVelocities = new Float32Array(LOX_COUNT * 3);

function initLoxParticle(i, stagger) {
    const angle = Math.random() * Math.PI * 2;
    const rad = LOX_CFG.r * (0.7 + Math.random() * 0.3);
    loxPositions[i * 3]     = Math.cos(angle) * rad;
    loxPositions[i * 3 + 1] = LOX_CFG.y - (stagger ? Math.random() * LOX_FALL_DIST : 0);
    loxPositions[i * 3 + 2] = Math.sin(angle) * rad;
    loxVelocities[i * 3]     = (Math.random() - 0.5) * 0.001;
    loxVelocities[i * 3 + 1] = -(0.004 + Math.random() * 0.006);
    loxVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.001;
    loxOpacities[i] = 0.5 + Math.random() * 0.3;
}
for (let i = 0; i < LOX_COUNT; i++) initLoxParticle(i, true);

const loxGeo = new THREE.BufferGeometry();
loxGeo.setAttribute('position', new THREE.BufferAttribute(loxPositions, 3));
loxGeo.setAttribute('aOpacity', new THREE.BufferAttribute(loxOpacities, 1));

const loxMat = new THREE.ShaderMaterial({
    uniforms: {
        uColor: { value: LOX_COLOR },
        uPointSize: { value: 2.0 * Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2) },
    },
    vertexShader: `
        attribute float aOpacity;
        varying float vOpacity;
        uniform float uPointSize;
        void main() {
            vOpacity = aOpacity;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = uPointSize * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        uniform vec3 uColor;
        varying float vOpacity;
        void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            gl_FragColor = vec4(uColor, vOpacity * (1.0 - dist * 2.0));
        }
    `,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
});

const loxPoints = new THREE.Points(loxGeo, loxMat);
stageGroups['sic'].add(loxPoints);

// ── Render loop ──────────────────────────────────────────────
let autoRot = 0;
const LERP = isMobile ? 0.12 : 0.09;
const MOUSE_LERP = isMobile ? 0.04 : 0.06;
const STAGE_FOLLOW = isMobile ? 0.12 : 0.07;

function animate() {
    requestAnimationFrame(animate);

    // Lerp per-group opacity + vertical separation
    for (const k of ALL_GROUPS) {
        opacityCurrent[k] += (opacityTarget[k] - opacityCurrent[k]) * STAGE_FOLLOW;
        for (const mat of stageMats[k]) {
            mat.opacity = opacityCurrent[k];
            if ('emissiveIntensity' in mat) mat.emissiveIntensity = 0.05 + opacityCurrent[k] * 0.2;
        }

        sepCurrent[k] += (sepTarget[k] - sepCurrent[k]) * STAGE_FOLLOW;
        stageGroups[k].position.y = sepCurrent[k];
    }

    // Liftoff: move entire rocket upward (slow, dramatic)
    liftoffYTarget = liftoffActive ? 20 : 0;
    liftoffYCurrent += (liftoffYTarget - liftoffYCurrent) * LERP * 0.15;
    rocketRoot.position.y = liftoffYCurrent;

    // Update LOX droplets (S-IC only)
    const isSicActive = activeStage === 'sic';
    const loxVisible = isSicActive || liftoffActive;
    const speedMult = liftoffActive ? 3.0 : 1.0;

    for (let i = 0; i < LOX_COUNT; i++) {
        loxPositions[i * 3]     += loxVelocities[i * 3] * speedMult;
        loxPositions[i * 3 + 1] += loxVelocities[i * 3 + 1] * speedMult;
        loxPositions[i * 3 + 2] += loxVelocities[i * 3 + 2] * speedMult;

        const fallDist = LOX_CFG.y - loxPositions[i * 3 + 1];
        loxOpacities[i] = loxVisible ? Math.max(0, 1.0 - fallDist / LOX_FALL_DIST) * 0.6 : 0;

        if (fallDist > LOX_FALL_DIST) {
            initLoxParticle(i, false);
            if (liftoffActive) {
                loxVelocities[i * 3]     = (Math.random() - 0.5) * 0.008;
                loxVelocities[i * 3 + 1] = -(0.02 + Math.random() * 0.03);
                loxVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.008;
            }
        }
    }
    loxGeo.attributes.position.needsUpdate = true;
    loxGeo.attributes.aOpacity.needsUpdate = true;
    loxMat.uniforms.uPointSize.value = (liftoffActive ? 4.0 : 2.0) * Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);

    // Lerp camera pose
    camXCurrent += (camXTarget - camXCurrent) * STAGE_FOLLOW;
    camYCurrent += (camYTarget - camYCurrent) * STAGE_FOLLOW;
    camZCurrent += (camZTarget - camZCurrent) * STAGE_FOLLOW;
    camLookYCurrent += (camLookYTarget - camLookYCurrent) * STAGE_FOLLOW;
    stageRotYCurrent += (stageRotYTarget - stageRotYCurrent) * STAGE_FOLLOW;

    camera.position.set(camXCurrent, camYCurrent, camZCurrent);
    camera.lookAt(0, camLookYCurrent, 0);

    // Sinusoidal auto-rotation + mouse influence
    const time = performance.now() * 0.001;
    if (isMobile) {
        targetRotY = 0;
        currentRotY += (0 - currentRotY) * MOUSE_LERP;
        rocketRoot.rotation.y = stageRotYCurrent;
    } else {
        autoRot += 0.003 + Math.sin(time * 0.5) * 0.001;
        currentRotY += (autoRot + targetRotY - currentRotY) * MOUSE_LERP;
        rocketRoot.rotation.y = stageRotYCurrent + currentRotY;
    }

    if (composer) composer.render();
    else renderer.render(scene, camera);
}
animate();

// ── RSS Loaders: Latest article + Transmission Logs ─────────
const RSS_URL = 'https://api.rss2json.com/v1/api.json?rss_url=https://kwerky.substack.com/feed';

(async function loadSubstackContent() {
    try {
        const resp = await fetch(RSS_URL);
        const data = await resp.json();
        if (data.status !== 'ok' || !data.items || !data.items.length) return;

        // ── Transmission Logs (top 4 posts) ──
        const container = document.getElementById('transmissions-container');
        if (container) {
            container.innerHTML = '';
            data.items.slice(0, 4).forEach(item => {
                const d = new Date(item.pubDate);
                const fmt = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }).toUpperCase();
                const tmp = document.createElement('div');
                tmp.innerHTML = item.description || '';
                const desc = tmp.textContent.trim().substring(0, 200) + '...';
                const el = document.createElement('a');
                el.className = 'transmission-item';
                el.href = item.link;
                el.target = '_blank';
                el.innerHTML = `
                    <div class="transmission-date">${fmt}</div>
                    <div class="entry-title">${item.title.toUpperCase()}</div>
                    <div class="transmission-excerpt">${desc}</div>
                `;
                container.appendChild(el);
            });
        }
    } catch (e) {
        // Fallback: silent — transmissions grid stays with loading text
    }
})();

// ── Panel fade-in observer ───────────────────────────────────
const fadeObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('visible');
        }
    });
}, { threshold: 0.15 });

document.querySelectorAll('.panel-card, .panel-dual-header, .transmissions-section').forEach(el => {
    fadeObserver.observe(el);
});
</script>

</body>
</html>
